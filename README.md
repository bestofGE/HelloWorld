## ***Linux 4가지 명령어***
---
### 1) **top(topas)**:
- 현재 OS의 상태를 나타내주는 CLI 어플리케이션으로, 메모리 사용량, CPU 사용량 등을 나타내준다.
- 전체 프로세스가 OS에 대해서 리소스를 어느정도 차지하고 있는지를 알려준다.
- 시간, 유저, 로드 에버리지, 테스크, CPU, 메모리 값을 확인할 수 있다.

**`$ top`**
        
![image](https://user-images.githubusercontent.com/82525776/172052383-9ad08a1f-2419-43ae-b246-d28221d5c4c9.png)


- top에서 상단에 위치한 요약영역:
- 시스템 현재 시간(GMT 기준), OS가 살아있는 시간, 유저 세션 수 
- 로드 애버리지(Load Average) : CPU Load(CPU가 수행하는 작업의 양)의 이동 평균을 표시한다. 리눅스에서는 실행되거나 대기중인 프로세스의 평균이다.

- 테스크(Tasks): 2번째 줄에 출력되는 내용으로 현재 프로세스들의 상태를 나타내주는 영역이다.
- Total은 전체 프로세스, running은 running 상태인 프로세스, sleeping은 대기상태인 process, stopped는 종료된 프로세스, zombies는 좀비상태인 프로세스의 수를 나타낸다.

- 실행(Runnable) - CPU에 의해서 명령어가 실행중인 Process
- 준비(Ready) - CPU의 명령어 실행을 기다리는 Process
- 대기(Waiting) - I/O operation이 끝나기를 기다리는 Process
- 종료(Terminated) - Ctrl + Z 등의 signal로 종료된 Process
- Zombie - Process는 root Process로 부터 뿌리내린 자식 Process의 형식으로 트리구조를 형성한다. 이 때 부모가 먼저 종료된다면 root process로 부터 닿을 수 없는 Process가 생기고 이를 zombie process라고 부른다.



### 2) **ps**:
`**$ ps [option]**`
- 프로세스의 약자로 추정되는 명령어 ps는 현재 돌아가고 있는 프로세스를 확인할 수 있는 명령어이다.
- 현재 실행중인 프로세스 목록과 상태를 보여준다.
- ps의 옵션은 전통적인 유닉스인 SystemB, BSD, GNU에 따라 결과가 다르게 나타나고 표기법에도 차이를 보인다. 
- V 계열은 대시(-)를 사용하고 BSD 계열은 대시(-)를 사용하지 않는다.
- GNU에서의 옵션 표기는 두 개의 대시(-)를 사용한다.
- 원하는 프로세스의 상태를 출력하려면 정확한 옵션 사용이 중요하다. 

|옵션|내용|
|:---:|:---:|
|-A|모든 프로세스를 출력한다.|
|a(BSD)|터미널과 연관된 프로세스를 출력하는 옵션이다. 보통 x 옵션과 연계하여 모든 프로세스를 출력할 때 사용한다.|
|-a|세션 리더를 제외하고 데몬 프로세스처럼 터미널에 종속되지 않은 모든 프로세스를 출력한다.|
|-e|커널 프로세스를 제외한 모든 프로세스를 출력해준다.|
|-f|풀 포맷으로 보여준다. 유닉스 스타일로 출력해주는 옵션으로 UID,PID,PPID등이 함께 표시된다.|
|-l(BSD)|프로세스의 정보를 길게 보여주는 옵션으로 우선순위와 관련된 PRIdhk NI값을 확인할 수 있다.|
|-o값|출력 포맷을 지정하는 옵션, 값으로는 pid, tty, time, cmd 등을 지정할 수 있다.|
|-M|64비트 프로세스들을 보여준다.|
|-m|프로세스들 뿐만 아니라 커널 스레드들도 보여준다.|
|-p|특정 PID를 지정할 때 사용한다.|
|-r|현재 실행 중인 프로세서를 보여준다.|
|u(BSD)|프로세스의 소유자를 기준으로 출력한다.|
|-u|특정 사용자의 프로세스 정보를 확인할 때 사용한다. 사용자를 지정하지 않으면 현재 사용자가 기준이다.|
|x(BSD)| 데몬 프로세스처럼 터미널에 종속되지 않는 프로세스를 출력한다. 보통 a옵션과 결합하여 모든 프로세스를 출력할 때 사용한다.|
|-x|로그인 상태에 있는 동안 아직 완료되지 않은 프로세서들을 보여준다. -x 옵션을 사용하면 자신의 터미널이 없는 프로세서들을 확인할 수 있다. |

**`$ ps`**
- 단독으로 사용하였을 때는 사용자와 관련된 프로세스를 출력한다. 
- 기본적으로 PID(프로세스 번호), TTY(프로세스가 연결된 터미널), TIME(총 CPU 사용시간), CMD(프로세스의 실행 명령행) 가 출력된다.

### 3) **jobs**:
**`$ jobs`**
- jobs는 작업의 상태를 표시하는 명령어다. 현재 쉘 세션에서 실행시킨 백그라운드 작업의 목록이 출력되며, 각 작업에는 번호가 붙어 있어 kill 명령어 뒤에 '%번호' 등으로 사용할 수 있다. 
- jobs로 출력되는 백그라운드 작업의 상태값은 다음의 표와 같다.

|상태|설명|
|:---:|:---:|
|Running|작업이 계속 진행중임|
|Done|작업이 완료되어 0을 반환|
|Done(code)|작업이 종료되었으며 0이 아닌 코드를 반환|
|Stopped|작업이 일시 중단|
|Stopped(SIGTSTP)|SIGTSTP 시그널이 작업을 일시 중단|
|Stopped(SIGSTOP)|SIGSTOP 시그널이 작업을 일시 중단|
|Stopped(SIGTTIN)|SIGTTIN 시그널이 작업을 일시 중단|
|Stopped(SIGTTOU)|SIGTTOU 시그널이 작업을 일시 중단|

### 4) **kill**:
**`$kill [옵션 or 시그널(번호 또는 이름)] PID`**
- 프로세스에 특정한 signal을 보내는 명령어일반적으로 종료되지 않는 프로세스를 종료 시킬 때 많이 사용한다.

1) SIGHUP : 연결 끊기. 프로세스의 설정파일을 다시 읽음
2) SIGINT : 인터럽트
3) SIGQUIT : 종료
4) SIGILL : 잘못된 명령
5) SIGTRAP : 트렙 추적
6) SIGABRT 
7) SIGBUS : 버스 에러 
8) SIGFPE : 고정 소수점 예외
9) SIGKILL : 죽이기
10) SIGUSR1
11) SIGSEGV : 세그멘테이션 위반
12) SIGUSR2      
13) SIGPIPE : 읽을 것이 없는 파이프에 대한 시그널
14) SIGALRM      : 경고 클럭
15) SIGTERM : 소프트웨어 종료 시그널 
16) SIGSTKFLT : 프로세서 스택 실패
17) SIGCHLD : 자식 프로세서의 상태변화 
18) SIGCONT : STOP 시그널 이후 계속 진행할 때 사용 
19) SIGSTOP       : 정지
20) SIGTSTP : 키보드에 의해 발생하는 시그널
••• 등이 있다.


## ***vim 에디터 매크로 사용방법***
---
### **<매크로 설정하는 법>**
- 1) vim의 중립모드에서 `q`를 누른 다음 매크로 이름으로 사용할 알파벳을 눌러준다. 
- 2) 예를 들어 매크로 이름을 a로 해서 `qa`라고 누르면 밑에 --recording-- 이라는 문구가 뜨면서 a라는 매크로의 기록이 시작된다. 
- 3) 원하는 동작들의 입력이 끝나면 다시 중립모드에서 `q`를 눌러준다. 

### **<매크로 재생하는 법>**
- 중립모드에서 `@a`를 누르면 매크로 a가 재생된다.
- `@@`를 누르면 제일 최근에 재생된 매크로가 재생된다.

### **<매크로를 파일로 저장하는 법>**
- ~/.vimrc 파일을 열고 매크로 이름을 a라고 했을 때 `let @a='`라고 친 다음에 입력모드에서 `^R^Ra`를 누르면 매크로 a의 내용이 입력된다. 
- 입력이 끝나면 `'`를 치고 마무리한다. 

### **<매크로 반복하는 법>**
- 매크로 a를 숫자 n번만큼 반복하고 싶다면 중립모드에서 `n@a`를 적어주면 된다.
        
